
\documentclass[12pt, a4paper]{article}

\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[russian]{babel}
\usepackage[oglav,spisok,boldsect,eqwhole,figwhole,hyperref,hyperprint,remarks,greekit]{./style/fn2kursstyle}
\graphicspath{{./style/}{./figures/}}

\usepackage{multirow}
\usepackage{supertabular}
\usepackage{multicol}
% Параметры титульного листа
\title{Задача об ограниченном ранце}
\author{З.\,И.~Абрамов}
\supervisor{А.\,Ю.~Попов}
\group{ФН2-42Б}
\date{2022}

% псевдокод
% https://harrix.dev/blog/2013/algorithmicx-cyrillic/
\usepackage{algorithm}
\usepackage[noend]{algpseudocode}
\newcommand{\algorithmicbreak}{\textbf{break}}
\newcommand{\Break}{\State \algorithmicbreak}

\usepackage{comment}

% Переопределение команды \vec, чтобы векторы печатались полужирным курсивом
%\renewcommand{\vec}[1]{\text{\mathversion{bold}${#1}$}}%{\bi{#1}}
%\newcommand\thh[1]{\text{\mathversion{bold}${#1}$}}
%Переопределение команды нумерации перечней: точки заменяются на скобки
\renewcommand{\labelenumi}{\theenumi)}

% Кастомный список вида Шаг *.
\usepackage{enumitem}
\newlist{STEP}{enumerate}{1}
\setlist[STEP]{label=\textbf{Шаг \arabic*.}, leftmargin=1.75cm}

% TODO в конце пройтись по оформлению текста, например, чтобы строка не заканчивалась на однобуквенный союз или предлог или чтобы последняя строка абзца была в 1,5 раза длиннее красной строки

\begin{document}

\maketitle

\tableofcontents

\newpage

\section-{Введение}

Классическая задача о рюкзаке (о загрузке) известна очень давно, и формулируется следующим образом. Пусть есть $n$ разных предметов, каждый предмет имеет вес $w_i$ и полезность $c_i$, так же имеется максимальный вес $W$, который можно положить в рюкзак. Требуется собрать такой набор предметов, чтобы полезность их была наибольшей, а суммарный вес не превышал $W$.
Несмотря на такую "бытовую"\, формулировку, решение данной задачи находит гораздо более широкое применение.

% https://docs.yandex.ru/docs/view?url=http%3A%2F%2Falgoritm-rukzaka.narod.ru%2Fo_rjukzake.pdf
% На основе задачи о ранце был разработан первый алгоритм шифрования с открытым ключом --- https://habr.com/ru/post/529346/ 
Задача о загрузке (или задача о рюкзаке) и различные ее модификации широко применяются на практике в прикладной математике, криптографии, экономике, логистике, для нахождения решения оптимальной загрузки различных транспортных средств: самолетов, кораблей, железнодорожных вагонов и т.д. Приведем в качестве примера задачу, которая представляет собой переиначенную задачу о ранце, чтобы показать, что алгоритмы для решения данной проблемы могут быть полезны не только в упаковке багажа:

% TODO сослаться на файл Book-advanced-algorithms.pdf с trello, находится на странице 98
Технология DVS\footnote{DVS (от англ. Dynamic Voltage Scaling) --- динамическое изменение напряжения.} позволяет снижать напряжение на процессоре и добиваться экономии электроэнергии за счет увеличения времени выполнения задачи.

Пусть процессор поддерживает два уровня напряжения --- $U_L < U_H$. Есть набор из $n$ задач, каждая из которых имеет энергоемкость и время выполнения для обоих режимов, т.е. для $i=1, \dots, n$ даны энергоемкости $c_i^H$ и $c_i^L$ и длительности $t_i^H$ и $t_i^L$.

Нужно выполнить все задачи на одном процессоре за время не более заданного~$T$, при этом добиться минимального энергопотребления.

\medskip

Рассматриваемая нами задача является $N\!P$-полной, то есть для нее не существует полиномиального алгоритма, решающего ее за разумное время, в этом и заключается основная проблема данной задачи. Решения $N\!P$-полных задач обычно делят на два типа: приближенные, работающие быстро, но далеко не всегда решающие задачу наилучшим образом, и точные, выполняемые сильно дольше, но гарантированно выдающие лучший результат.

% https://neerc.ifmo.ru/wiki/index.php?title=Задача_о_рюкзаке
Существует несколько модификаций задачи о ранце. Ниже приведены некоторые из них.
\begin{enumerate}
	\item Каждый предмет можно брать только один раз.
	\item Каждый предмет можно брать сколько угодно раз.
	\item Каждый предмет можно брать определенное количество раз.
	\item Можно брать дробную часть предмета.
\end{enumerate}

\medskip
\underline{Цель данной работы} --- реализовать решение для задачи 3) двумя точными алгоритмами, а именно методом ветвей и границ и динамическим программирова\-нием, на языке программирования C++ и в системе компьютерной алгебры Wolfram Mathematica. Также исследовать время выполнения и сложность алгоритмов.

\section{Постановка задачи}

Математически задачу об ограниченном рюкзаке можно представить следующим образом:
\begin{equation}
	\label{problem}
	\begin{gathered}
		\sum_{i=1}^{n} c_i x_i \rightarrow \max, \\
		\sum_{i=1}^{n} w_i x_i \le W, \\
		x_i \in \{0,1,\dots,k_i\},
	\end{gathered}
\end{equation}
где $c_i$, $w_i$ и $k_i$ --- стоимость, вес и максимальное количество предмета $i$ соответственно; $W$ --- максимальная грузоподъемность ранца; $n$ --- количество предметов.

Очевидно, что сложность алгоритма, осуществляющего полный перебор, т.е. проверяющего всевозможные наборы предметов, пропорциональна количеству этих возможные наборов. Таким образом он имеет сложность $O(K^n)$, где $K = \max\limits_{i=1,\dots,n} k_i$, что очень неэффективно. Поэтому, как и во многих других задачах, есть методы решения задачи, которые выполняются быстрее обычного перебора.

\section{Метод ветвей и границ}

% TODO сослаться на файл метод ветвей и границ умными словами.pdf
Метод ветвей и границ (МВГ) относится к числу основных методов решения задач оптимизации. Этот метод основан на древовидной декомпозиции исходной задачи на подзадачи.

В процессе дальнейшего изложения мы будем часто употреблять термин рекорд, означающий наилучшее найденное значение целевой функции к данному шагу алгоритма. Предполагается, что рекорд, также как и целевая функция, принимает действительные значения.

% TODO ссылка на что?
Различные варианты МВГ имеют специфичные для решаемой задачи особенности, но при этом подчиняются следующей общей схеме [4]:

\textbf{Данные:} рекорд, список подзадач.

\begin{STEP}
\item В список подзадач помещается исходная задача.
\item Если список подзадач пуст, то завершить алгоритм. В противном случае из списка выбирается и удаляется подзадача $P$.
\item Вычисляется значение целевой функции, и при необходимости обновляется значение рекорда. Для задачи $P$ проверяется выполнимость условия отсева. Если подзадача $P$ удовлетворяет условию отсева, то осуществляется переход к шагу 2.
\item Задача $P$ подвергается декомпозиции. Полученные в результате подзадачи помещаются в список подзадач. Перейти к шагу 2.
\end{STEP}

Т.е. конкретный вариант метода ветвей и границ определяется следующими тремя функциями: выбором подзадачи из списка; условием отсева; правилом декомпозиции, определяющим, каким образом разбивается очередная подзадача.

Опишем данные функции для задачи об ограниченном ранце.

Для начала запишем линейную задачу релаксацию, соответствующей задаче \eqref{problem}:
\begin{equation}
	\label{relax_problem}
	\begin{gathered}
		\sum_{i=1}^{n} c_i x_i \rightarrow \max, \\
		\sum_{i=1}^{n} w_i x_i \le W, \\
		0 \le x_i \le k_i.
	\end{gathered}
\end{equation}

Оптимум задачи \eqref{relax_problem} не меньше оптимума исходной задачи \eqref{problem}. Задача релаксации представляет собой одномерную задачу линейного программирования и может быть решена методом Данцига следующим образом. Переменные нумеруются в порядке возрастания удельной стоимости:
\[
\frac{c_1}{w_1} \ge \dots \ge \frac{c_n}{w_n}.
\]

Сначала определяется номер $s$ дробной переменной по следующему правилу:
\[
s = \min \left\{j \in \{1,\dots, n\} : \sum_{i=1}^j k_i w_i > W \right\}.
\]

Таким образом решение состоит из предметов $i = 1, \dots, (s-1)$ в количестве $k_i$ и предмета $s$ в количестве
\[
K = \frac{W - \sum\limits_{i=1}^{s-1} k_i w_i}{w_s},
\]
а стоимость итогового набора задачи \eqref{relax_problem}
\[
S = \sum_{i=1}^{s-1} k_i c_i + K\cdot c_s.
\]

Данный алгоритм имеет сложность $O(n)$. На основании данного решения введем функцию $S(i, w)$, решающую аналогичную задачу для предметов $j = i,\dots, n$ и вместимости рюкзака $w$, т.е. $S$, определенное выше, для задачи \eqref{relax_problem} есть значение $S(1, W)$.

Теперь сформулируем, что будем понимать под подзадачей в рамках загрузки рюкзака. Пусть мы зафиксировали количество у первых $m$ предметов. Данный набор имеет стоимость $C'$ и вес $W'$. Тогда под подзадачей будем называть следущее:
\begin{equation}
	\label{subproblem}
	\begin{gathered}
		C' + \sum_{i=m+1}^{n} c_i x_i \rightarrow \max, \\
		\sum_{i=m+1}^{n} w_i x_i \le W - W', \\
		x_i \in \{0,1,\dots,k_i\} \textrm{ при } i=(m+1),\dots, n.
	\end{gathered}
\end{equation}

Теперь мы готовы, наконец, сформулировать три функции, характеризующие метод ветвей и границ.

Правило декомпозиции. Исходную подзадачу \eqref{subproblem} будем разбивать на $(k_{m+1}+1)$ подзадач, фиксируя в каждой новой такой задаче предмет $(m + 1)$ в количестве $0, 1, 2, \dots, k_{m+1}$ раз. Отметим, что если в подзадаче \eqref{subproblem} присутствует всего один предмет $n$, то нет смысла разбивать ее на подзадачи, потому что мы можем сразу дать на нее ответ.

% идею с жадным алгоритом я взял со stack overflow
Выбор подзадачи из списка. В основном, выбор подзадачи можно сделать произвольной, но мы будем пользоваться логикой жадных алгоритмов. Чтобы задача релаксации выполнялась за $O(n)$ необходимо, чтобы предметы изначально были отсортированы по убыванию удельной стоимости, поэтому будем предполагать, что предметы изначально отсортированы. Таким образом можно предположить, что нам выгодней взять как можно больше первых предметов. Поэтому после декомпозиции мы сначала будем рассматривать задачу при условии, что мы взяли предмет $(m+1)$ в количестве $k_{m+1}$, потом $(k_{m+1} - 1)$ и т.д.

Условие отсева. Подзадача не подлежит дальнейшей декомпозиции если:
\begin{enumerate}
	\item подзадача не имеет решения, что возможно только при условии $W' < 0$;
	\item оптимум задачи \eqref{relax_problem} не превосходит значения рекорда (тогда, как было отмечено выше, оптимум задачи \eqref{subproblem} тоже не превосходит значения рекорда).
\end{enumerate}

Сложность алгоритма метода ветвей и границ составляет, как и при переборе,~$O(K^n)$, где $K = \max\limits_{i=1,\dots,n} k_i$, т.к. может произойти ситуация, что условие отсева выполнено для каждой подзадачи и мы будем вынуждены рассмотреть все возможные подзадачи данной подзадачи.

\section{Реализация метода ветвей и границ}

\subsection{Особенности реализации на языке C++}

% TODO написать

\subsection{Особенности реализации на Wolfram Mathematica}

% TODO написать

\section{Метод динамического программирования}
% https://ru.m.wikipedia.org/wiki/Динамическое_программирование
Словосочетание "динамическое программирование"\, впервые было использовано в 1940-х годах Ричардом Беллманом\footnote{Ричард Эрнест Беллман (26 августа 1920, Нью-Йорк, США -- 19 марта 1984, Лос-Анджелес, США) --- американский математик, один из ведущих специалистов в области математики и вычислительной техники. Член Национальной инженерной академии США (1977), Национальной академии наук США (1983).} для описания процесса нахождения решения задачи, где ответ на одну задачу может быть получен только после решения задачи, "предшествующей"\, ей. В 1953 году он уточнил это определение до современного. Вклад Беллмана в динамическое программирование был увековечен в названии уравнения Беллмана, центрального результата теории динамического программирования, который переформулирует оптимизационную задачу в рекурсивной форме.
% TODO можно добавить формулу Белмана

Слово "программирование"\, в словосочетании "динамическое программирование"\, в действительности к "традиционному"\, программированию (написанию кода) почти никакого отношения не имеет. Слово "программа"\, в данном контексте скорее означает оптимальную последовательность действий для получения решения задачи. К примеру, определенное расписание событий на выставке иногда называют программой.

Динамическое программирование --- способ решения сложных задач путем разбиения их на более простые подзадачи. Ключевая идея в динамическом программировании достаточно проста. Как правило, чтобы решить поставленную задачу, требуется решить отдельные части задачи (подзадачи), после чего объединить решения подзадач в одно общее решение. Часто многие из этих подзадач одинаковы. Подход динамического программирования состоит в том, чтобы решить каждую подзадачу только один раз, сократив тем самым количество вычислений. Это особенно полезно в случаях, когда число повторяющихся подзадач экспоненциально велико.

% TODO можно расписать про виды ДП

% TODO сослаться на https://habr.com/ru/post/191498/
Чтобы успешно решить задачу динамикой нужно:
\begin{enumerate}
	\item состояние динамики: параметр(ы), однозначно задающие подзадачу;
	\item значения начальных состояний;
	\item переходы между состояниями: формула пересчета;
	\item порядок пересчета;
	\item положение ответа на задачу: иногда это сумма или, например, максимум из значений нескольких состояний.
\end{enumerate}

Для решения нашей задачи введем двумерный массив $dp$ размером $n+1$ на $W+1$, где в $dp[i, w]$ будем хранить максимально возможную стоимость набора состоящая из первых $i$ предметов при максимальной допустимой нагрузке $w$. Теперь распишем пункты выше.
\begin{enumerate}
	\item состояние динамики: $dp[i, w]$;
	\item начальные состояния: $dp[0, w]$ и $dp[i, 0]$ равны нулю, т.е. если у нас нет никаких вещей или мы не можем ничего положить в рюкзак, то и максимально возможная стоимость равна нулю;
	\item формула пересчета: $dp[i, w] = \!\max\limits_{x_j = 0,1,\dots, m(i,w)} \left(x_j\cdot c_i + dp[i-1, w - x_j\cdot w_i]\right)$, где \linebreak $m(i, w)$ --- максимальное количество предмета $i$, которое влезает в рюкзак вместимости $w$, ограниченное при этом максимальным количеством $k_i$, таким образом $m(i, w) = \min\left\{k_i;\; \left\lfloor\sfrac{w}{w_i}\right\rfloor\right\}$;
	\item пересчитывать будем в следующем порядке: для каждого $i$ будем заполнять строку $dp[i, w]$, $w$ изменяется в диапазоне от 1 до $W$, т.е. постепенно будем добавлять каждый предмет по порядку;
	\item ответ будет находится в ячейке $dp[n, W]$, т.к. это именно та задача, которую нам надо решить, для всех $n$ предметов при емкости рюкзака $W$.
\end{enumerate}

% TODO сослаться на https://neerc.ifmo.ru/wiki/index.php?title=Задача_о_рюкзаке
Таким образом, заполнение массива $dp$ можно представить в виде следующего псевдокода:
% TODO проследить, чтобы весь псевдокод был на одной странице
\begin{algorithmic}[1]
	\For{$w=0 \textbf{ to } W$}
	\State $dp[0, w] = 0$
	\EndFor
	
	\For{$i=1 \textbf{ to } n$}
		\For{$w=1 \textbf{ to } W$}
			\State $dp[i, w] = dp[i-1, w]$
			\For{$x_j = \min\left\{k_i, \left\lfloor\sfrac{w}{w_i}\right\rfloor\right\} \textbf{ downto 1}$}
				\State $dp[i, w] = \max\Big\{dp[i, w];\;\, x_j\cdot c_i + dp[i-1, w - x_j\cdot w_i]\Big\}$
			\EndFor
		\EndFor
	\EndFor
\end{algorithmic}

% взято отсюда https://algorithmica.org/tg/knapsack-gis-gcs
\looser{-0.02}{Такое решение работает за $O(n\,W^2)$, так как $k_i$ могут быть очень большими, а $w_i = 1$.}

% TODO можно вставить сюда таблицу 1.5 из файла mdo2p.pdf, как пример заполненной таблицы dp, ну и плюс уже будет не чисто текст, а с какой-то графикой

Теперь опишем восстановление одного из решений также в виде псевдокода.
% TODO проследить, чтобы весь псевдокод был на одной странице
\begin{algorithmic}[1]
	\State $w = W$
	\State $solution = \{\;\}$
	\For{$i=n \textbf{ downto } 1$}
		\If{$w = 0$}
			\Break
		\EndIf
		\State \parbox[t]{\dimexpr12cm-\algorithmicindent}{Находим $mVal = \max\limits_{x_j = 0,1,\dots, m(i,w)} \left(x_j\cdot c_i + dp[i-1, w - x_j\cdot w_i]\right)$ и $mCnt = x_j$, на котором достигается $mVal$}
		\If{$mCnt \ne 0$}
			\State \parbox[t]{\dimexpr11.5cm-\algorithmicindent}{Добавляем в решение $solution$ предмет $i$ в количестве $mCnt$ штук}
			% эти страшные команды нужны для красивого знака -=
			\State $w\,\,\scalebox{0.75}[1.0]{\(-\)}\!\!=\, w_i \cdot mCnt$
		\EndIf
	\EndFor
\end{algorithmic}

Впоследствии выполнения алгоритма итоговое решение будет представлено массивом $solution$. Сложность алгоритма восстановления одного решения составляет $O(n)$, потому что в общем случае мы пройдем по всем $n$ предметам.

В итоге алгоритм имеет временную сложность $O(n\,W^2)$, а по памяти $O(n\,W)$, которая требуется на хранение массива $dp$. Также заметим, что если требуется найти только максимальную стоимость набора, не восстанавливая само решение, то потребление памяти можно сократить до $O(W)$, храня только две последние рассматриваемые строчки.

\section{Реализация метода динамического программирования}

\subsection{Особенности реализации на языке C++}

% TODO написать

\subsection{Особенности реализации на Wolfram Mathematica}

% TODO написать

\section{Примеры работы программ}

% TODO написать

% TODO здесь должен быть график, похожий на диаграмму 1 в файле o_rjukzake.pdf с trello

\section-{Заключение}

% TODO написать

\begin{thebibliography}{10}
% оставил для примера
\bibitem{Kempka} Kempka S.N., Glass M.W., Peery J.S., Strickland J.H., Ingber M.S. Accuracy considerations for implementing velocity boundary conditions in vorticity formulations // SANDIA report. SAND96-0583, UC-700. 1996. 52 p.
\end{thebibliography}

\end{document} 